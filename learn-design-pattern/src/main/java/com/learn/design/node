** 单例模式 **
    一、什么是单例模式
    1、所谓类的单例设计模式，就是 采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，
    2、并且该类只提供一个取得其对象实例的方法(静态方法)。
    比如 Hibernate 的 SessionFactory，它充当数据存储源的代理，并负责创建 Session 对象。
    SessionFactory 并不是轻量级的，一般情况下，一个项目通常只需要一个 SessionFactory 就够，这是就会使用到单例模式。

    二、单例模式总工有8种写法：
    1、饿汉式 静态常量    (在不确定一定用到的时候会浪费内存,线程安全)    final static Singleton INSTANCE = new Singleton();
    2、饿汉式 静态代码块  (在不确定一定用到的时候会浪费内存,线程安全)    static {INSTANCE = new Singleton();}
    3、懒汉式 使用再创建  (线程不安全)              getInstance();
    4、懒汉式 同步方法    (线程安全了，效率低)       synchronized getInstance();
    5、懒汉式 同步代码块  (反而线程不安全了)         synchronized(){}
    6、懒汉式 双重检索    (线程安全)                volatile + 双if + 静态代码块
    7、静态内部类        1、利用JVM类加载器加载外部类时不加载静态内部类   2、利用JVM装载类去保证线程安全
    8、枚举             利用jdk1.5之后枚举类的特性

    三、推荐使用的有：
    在确保类一定会使用的时候，饿汉式两种可以使用。(1、2)
    双重检索、静态内部类、枚举 可以使用。(6、7、8)

    四、单例模式的经典使用：
    JDK中的 java.lang.Runtime就是单例模式。
    使用的是饿汉式写法。
    如下：
    private static Runtime currentRuntime = new Runtime();
    public static Runtime getRuntime() { return currentRuntime; }
    private Runtime() {}

    五、使用注意细节：
    1、单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能
    2、当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用 new
    3、单例模式的使用的场景：需要 频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多
    (即：重量级对象)，但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象(比如：数据源、session  工厂等)






** 工厂模式（简单工厂、工厂方法、抽象工厂） **
    一、简单工厂模式
    简单工厂模式是属于创建型模式，是工厂模式的一种。
    简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。
    简单工厂模式是 工厂模式家族 中最简单实用的模式。
    简单工厂模式：定义了一个创建对象的类，由这个类来 封装实例化对象的行为(代码)。
    在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式。

    二、工厂方法
    工厂方法模式： 定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。

    三、抽象工厂
    抽象工厂模式：定义了一个 interface  用于创建相关或有依赖关系的对象簇，而无需指明具体的类。
    抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。
    从设计层面看，抽象工厂模式就是对简单工厂模式的改进(或者称为进一步的抽象)。
    将工厂抽象成 两层，AbsFactory( 抽象工厂) 和  具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。
    这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。

    四、JDK中对工厂模式的运用
    Calendar类  使用的是简单工厂模式
    getInstance() ->  createCalendar(TimeZone zone,Locale aLocale) switch判断 Local对象 去创建不用的日历对象返回
    class JapaneseImperialCalendar extends Calendar{...}
    class BuddhistCalendar extends GregorianCalendar{...}
    ...

    五、工厂模式小节
    工厂模式的意义
        将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。
    三种工厂模式
        简单工厂模式、工厂方法模式、抽象工厂模式。
    设计模式的依赖抽象原则
        创建对象实例时，不要直接new类,而是把这个new类的动作放在一个工厂的方法中，并返回。
        有的书上说，变量不要直接持有具体类的引用。
        不要让类继承具体类，而是继承抽象类或者是实现 interface(接口)。
        不要覆盖基类中已经实现的方法。






** 原型模式 **

    一、什么是原型模式
    Java 中 Object 类是所有类的根类，Object 类提供了一个 clone()方法，该方法可以将一个 Java 对象复制一份，
    但是需要实现 clone的Java类必须要实现一个接口Cloneable，该接口表示该类能够复制且具有复制的能力 => 原型模式。

    原型模式(Prototype 模式)是指：用 原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象。
    原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节。
    工作原理是:通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即  对象.clone()。
    形象的理解：孙大圣拔出猴毛， 变出其它孙大圣。

    二、Spring Bean的创建过程中使用到了原型模式
    AbstractBeanFactory 类  doGetBean() 方法里判断配置文件的配置类型
      if (mbd.isSingleton()) ...
      else if (mbd.isPrototype())

    三、浅拷贝和深拷贝
    浅拷贝
    对于数据类型是 基本数据类型 的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。
    对于数据类型是 引用数据类型 的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，
       也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。
    因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。
    实现Cloneable接口的克隆办法就是浅拷贝。

    深拷贝
    复制对象的所有基本数据类型的成员变量值。
    所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。
       也就是说，对象进行深拷贝要对整个对象(包括对象的引用类型) 进行拷贝。
    深拷贝实现方式 1：重写 clone 方法来实现深拷贝。
    深拷贝实现方式 2：通过 对象序列化实现深拷贝(推荐)。











































